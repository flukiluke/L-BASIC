'Copyright Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'memory.bm - Memory access and addressing routines

function imm_add_offset(base_addr, offset)
    'The base_addr might be negative if it is a heap address, so "pass through"
    'the negative sign. e.g. base_addr = -10, offset = 2, result = -12
    imm_add_offset = (abs(base_addr) + offset) * sgn(base_addr)
end function

'Get the address of a variable. Handles simple scalars, elments of nested UDTs & arrays,
'and entire UDTs & arrays. If the returned value is < 0, it is a heap address. Otherwise,
'it is a stack address.
function imm_get_addr(node)
    addr = imm_get_addr_loc(node)
    if imm_needs_deref(node) then
        if addr = 0 then imm_error "Access to uninitialised variable"
        addr = imm_get_at_addr_n(addr)
    end if
    imm_get_addr = addr
end function

function imm_needs_deref(node)
    'TODO: Is a dereference check needed for UDT or array accesses?
    var = node->ref
    imm_needs_deref = node->atype = AST_VAR and var->vflags AND SYM_VARIABLE_DEREF
end function

'Like imm_get_addr, but does not do a final dereference even if the variable is a
'reference. This is useful for initialising or otherwise setting the actual address
'of a variable.
function imm_get_addr_loc(node)
    var = node->ref
    select case node->atype
    case AST_VAR
        if var->vflags AND SYM_VARIABLE_MAINFRAME then
            'shared or static variable
            '+1 because the addresses are offsets, but memory starts at 1
            imm_get_addr_loc = 1 + var->stack_offset
        else
            'local variable
            imm_get_addr_loc = imm_stack_base + var->stack_offset
        end if
    case AST_UDT_ACCESS
        base_addr = imm_get_addr(ast_get_child(node, 1))
        offset = var->stack_offset
        imm_get_addr_loc = imm_add_offset(base_addr, offset)
    case AST_ARRAY_ACCESS
        array = ast_get_child(node, 1)
        array_type = type_of_lvalue(array)
        desc = imm_get_addr(array)
        if desc = 0 then imm_error "Access to uninitialised array"
        element_type = array_type->array_type
        dimensions = imm_arr_get_dims(desc)
        'Make sure we have precisely enough indicies for the number of dimensions
        if dimensions <> ast_num_children(node) - 1 then
            imm_error "Incorrect number of indicies for array access"
        end if
        block_size = 1
        for i = 1 to dimensions
            dim index as imm_value_t
            lower_bound = imm_arr_get_lbound(desc, i)
            upper_bound = imm_arr_get_ubound(desc, i)
            imm_eval ast_get_child(node, i + 1), index
            if index.n < lower_bound or index.n > upper_bound then
                imm_error "Array access out of bounds"
            end if
            offset = offset + (index.n - lower_bound) * block_size
            block_size = upper_bound - lower_bound + 1
        next i
        offset = offset * type_fixed_size(element_type)
        imm_get_addr_loc = imm_add_offset(imm_arr_get_data_addr(desc), offset)
    case else
        imm_error "Attempt to take address of something not an lvalue"
    end select
end function

sub imm_set_at_addr(addr, v as imm_value_t)
    $if DEBUG_MEM_TRACE then
    debuginfo "Write [" + str$(addr) + " ] = " + str$(v.n) + " " + v.s
    $end if
    if addr < 0 then
        imm_heap(-addr) = v
    elseif addr > 0 then
        imm_stack(addr) = v
    else
        imm_error "Null pointer value write"
    end if
end sub

sub imm_set_at_addr_s(addr, v$)
    $if DEBUG_MEM_TRACE then
    debuginfo "Write [" + str$(addr) + " ] =" + v$
    $end if
    if addr < 0 then
        imm_heap(-addr).s = v$
    elseif addr > 0 then
        imm_stack(addr).s = v$
    else
        imm_error "Null pointer string write"
    end if
end sub

sub imm_set_at_addr_n(addr, n as _float)
    $if DEBUG_MEM_TRACE then
    debuginfo "Write [" + str$(addr) + " ] =" + str$(n)
    $end if
    if addr < 0 then
        imm_heap(-addr).n = n
    elseif addr > 0 then
        imm_stack(addr).n = n
    else
        imm_error "Null pointer numeric write"
    end if
end sub

sub imm_get_at_addr(addr, v as imm_value_t)
    $if DEBUG_MEM_TRACE then
    debuginfo "Read [" + str$(addr) + " ]"
    $end if
    if addr < 0 then
        v = imm_heap(-addr)
    elseif addr > 0 then
        v = imm_stack(addr)
    else
        imm_error "Null pointer value read"
    end if
    $if DEBUG_MEM_TRACE then
    debuginfo "=" + str$(v.n) + " " + v.s
    $end if
end sub

function imm_get_at_addr_s$(addr)
    $if DEBUG_MEM_TRACE then
    debuginfo "Read [" + str$(addr) + " ]"
    $end if
    if addr < 0 then
        r$ = imm_heap(-addr).s
    elseif addr > 0 then
        r$ = imm_stack(addr).s
    else
        imm_error "Null pointer string read"
    end if
    imm_get_at_addr_s$ = r$
    $if DEBUG_MEM_TRACE then
    debuginfo "=" + r$
    $end if
end sub

function imm_get_at_addr_n##(addr)
    $if DEBUG_MEM_TRACE then
    debuginfo "Read [" + str$(addr) + " ]"
    $end if
    if addr < 0 then
        r## = imm_heap(-addr).n
    elseif addr > 0 then
        r## = imm_stack(addr).n
    else
        imm_error "Null pointer numeric read"
    end if
    imm_get_at_addr_n## = r##
    $if DEBUG_MEM_TRACE then
    debuginfo "=" + str$(r##)
    $end if
end function

sub imm_memset(addr, size, value as imm_value_t)
    $if DEBUG_MEM_TRACE then
    debuginfo "Write [" + str$(addr) + "+" + str$(size) + "] =" + str$(value.n) + " " + value.s
    $end if
    if addr < 0 then
        for i = addr to imm_add_offset(addr, size - 1) step -1
            imm_heap(-i).s = value.s
            imm_heap(-i).n = value.n
        next i
    elseif addr > 0 then
        for i = addr to imm_add_offset(addr, size - 1)
            imm_stack(i).s = value.s
            imm_stack(i).n = value.n
        next i
    else
        imm_error "Null pointer write"
    end if
end sub
