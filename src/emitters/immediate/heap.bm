'Copyright 2020 Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'heap.bm - Heap data management

'The heap is used for allocating dynamically sized objects, or objects
'that are not necessarily tied to a single function's scope.
'
'Block header:
' - size of region, including header
' - pointer to next free region
'Blocks are in a cyclic linked list.
'
'The list of free blocks is searched until a suitable sized block is found.
'If the block is bigger than needed, the tail end is returned. Blocks are
'always allocated in sizes a multiple of IMM_HEAP_HEADER_SIZE. Freed blocks
'will be coalesced with an adjacent free block if possible.
'
'This is based on the allocator presented in Chapter 8.7 of K&R C.

'Allocate 'req_elems' elements on the heap and return start address.
function imm_heap_alloc(req_elems)
    'Calculate needed size to the next multiple of IMM_HEAP_HEADER_SIZE,
    'including +1 for the header itself.
    nelems = (_ceil(req_elems / IMM_HEAP_HEADER_SIZE) + 1) * IMM_HEAP_HEADER_SIZE
    prevp = imm_heap_next_free
    p = imm_heap(prevp + 1).n
    do
        if (imm_heap(p).n >= nelems) then 'big enough
            if (imm_heap(p).n = nelems) then 'exactly
                imm_heap(prevp + 1).n = imm_heap(p + 1).n
            else 'split block, allocate tail end
                imm_heap(p).n = imm_heap(p).n - nelems
                p = p + imm_heap(p).n
                imm_heap(p).n = nelems
            end if
            imm_heap_next_free = prevp
            imm_heap_alloc = -(p + IMM_HEAP_HEADER_SIZE)
            $if DEBUG_HEAP then
            imm_heap_current_blocks = imm_heap_current_blocks + 1
            imm_heap_current_bytes = imm_heap_current_bytes + nelems
            if imm_heap_current_blocks > imm_heap_max_blocks then imm_heap_max_blocks = imm_heap_current_blocks
            if imm_heap_current_bytes > imm_heap_max_bytes then imm_heap_max_bytes = imm_heap_current_bytes
            debuginfo "Allocated" + str$(nelems) + " elements at " + str$(-p - IMM_HEAP_HEADER_SIZE)
            $end if
            exit function
        end if
        if p = imm_heap_next_free then 'wrapped around free list
            p = imm_heap_expand(nelems)
        end if
        prevp = p
        p = imm_heap(p + 1).n
    loop
end function

'Make a copy of the block at address
function imm_heap_copy_alloc(address)
    size = imm_heap(-address - IMM_HEAP_HEADER_SIZE).n - IMM_HEAP_HEADER_SIZE
    new_block = imm_heap_alloc(size)
    $if DEBUG_HEAP then
    debuginfo "Copying" + str$(size) + " elements from " + str$(address) + " to " + str$(new_block)
    $end if
    for i = 0 to size - 1
        imm_heap(-new_block + i) = imm_heap(-address + i)
    next i
    imm_heap_copy_alloc = new_block
end function

'Free allocation at 'address'
sub imm_heap_free(address)
    data_addr = -address 
    addr = data_addr - IMM_HEAP_HEADER_SIZE
    p = imm_heap_next_free 'Start at next free block
    'Search for p s.t. addr is between p and next block address
    while not (addr > p and addr < imm_heap(p + 1).n)
        if p >= imm_heap(p + 1).n and (addr > p or addr < imm_heap(p + 1).n) then
            'Freed block at start or end of memory region
            exit while
        end if
        p = imm_heap(p + 1).n
    wend
    if addr + imm_heap(addr).n = imm_heap(p + 1).n then
        'Adjacent to upper block
        imm_heap(addr).n = imm_heap(addr).n + imm_heap(imm_heap(p + 1).n).n
        imm_heap(addr + 1).n = imm_heap(imm_heap(p + 1).n + 1).n
    else
        imm_heap(addr + 1).n = imm_heap(p + 1).n
    end if
    if p + imm_heap(p).n = addr then
        'Adjacent to lower block
        imm_heap(p).n = imm_heap(p).n + imm_heap(addr).n
        imm_heap(p + 1).n = imm_heap(addr + 1).n
    else
        imm_heap(p + 1).n = addr
    end if
    imm_heap_next_free = p
    $if DEBUG_HEAP then
    imm_heap_current_blocks = imm_heap_current_blocks - 1
    imm_heap_current_bytes = imm_heap_current_bytes - imm_heap(addr).n
    debuginfo "Freed" + str$(imm_heap(addr).n) + " elements at " + str$(address)
    $end if
end sub

'Setup initial heap
sub imm_heap_init
    redim imm_heap(1 to 2) as imm_value_t
    imm_heap(1).n = 0
    imm_heap(2).n = 1
    imm_heap_next_free = 1
end sub

'Increase the total heap size by adding new memory to list
function imm_heap_expand(nu)
    const IMM_HEAP_MIN_ALLOC = 1024 'Value from K&R, rather arbitrary
    nelems = nu
    if nelems < IMM_HEAP_MIN_ALLOC then nelems = IMM_HEAP_MIN_ALLOC
    new_mem = ubound(imm_heap) + 1
    redim _preserve imm_heap(1 to ubound(imm_heap) + nelems) as imm_value_t
    $if DEBUG_HEAP then
    debuginfo "Expand heap to" + str$(ubound(imm_heap)) + " elements"
    imm_heap_current_blocks = imm_heap_current_blocks + 1
    imm_heap_current_bytes = imm_heap_current_bytes + nelems
    $end if
    imm_heap(new_mem).n = nelems
    imm_heap_free -(new_mem + IMM_HEAP_HEADER_SIZE)
    imm_heap_expand = imm_heap_next_free
end sub

sub imm_heap_stats
    print #logging_file_handle, "Total heap allocation:"; ubound(imm_heap); " elements"
    print #logging_file_handle, "Current heap:"; imm_heap_current_blocks; " blocks /"; imm_heap_current_bytes; " elements"
    print #logging_file_handle, "Max heap:"; imm_heap_max_blocks; " blocks /"; imm_heap_max_bytes; " elements"
end sub
