'Copyright Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'array.bm - Array handling functions

'Array descriptor:
' - pointer to data
' - number of dimensions
' - owner ID
' - lbound of leftmost dimension
' - ubound of leftmost dimension
' - etc.
' - lbound of rightmost dimension
' - ubound of rightmost dimension
function imm_arr_get_data_addr(desc): imm_arr_get_data_addr = imm_get_at_addr_n(desc): end function
function imm_arr_get_dims(desc): imm_arr_get_dims = imm_get_at_addr_n(imm_add_offset(desc, 1)): end function
function imm_arr_get_owner(desc): imm_arr_get_owner = imm_get_at_addr_n(imm_add_offset(desc, 2)): end function
function imm_arr_get_lbound(desc, d): imm_arr_get_lbound = imm_get_at_addr_n(imm_add_offset(desc, d * 2 + 1)): end function
function imm_arr_get_ubound(desc, d): imm_arr_get_ubound = imm_get_at_addr_n(imm_add_offset(desc, d * 2 + 2)): end function
sub imm_arr_set_data_addr(desc, addr): imm_set_at_addr_n desc, addr: end sub
sub imm_arr_set_dims(desc, num): imm_set_at_addr_n imm_add_offset(desc, 1), num: end sub
sub imm_arr_set_owner(desc, id): imm_set_at_addr_n imm_add_offset(desc, 2), id: end sub
sub imm_arr_set_lbound(desc, d, b): imm_set_at_addr_n imm_add_offset(desc, d * 2 + 1), b: end sub
sub imm_arr_set_ubound(desc, d, b): imm_set_at_addr_n imm_add_offset(desc, d * 2 + 2), b: end sub
function imm_arr_calc_desc_size(dims): imm_arr_calc_desc_size = dims * 2 + 3: end function

'Allocate array memory if it is not allocated. This contrasts with imm_do_array_resize
'in that it does not touch the data if the array is already allocated.
sub imm_do_array_establish(node)
    array = ast_get_child(node, 1)
    desc = imm_get_addr(array)
    if imm_arr_get_data_addr(desc) <> 0 then exit sub
    imm_array_init node
end sub

'Claim ownership of an array for the current scope if unowned
sub imm_do_array_claim(node)
    array = ast_get_child(node, 1)
    imm_array_claim(array)
end sub

sub imm_array_claim(array)
    desc = imm_get_addr(array)
    $if DEBUG_OWNERS then
    debuginfo _trim$(str$(imm_stack_base)) + " tries to claim array at " + str$(desc)
    $end if
    'Don't try claim arrays that haven't been instantiated
    if desc = 0 then exit sub
    owner = imm_arr_get_owner(desc)
    $if DEBUG_OWNERS then
    if owner = 0 then
        imm_arr_set_owner desc, imm_stack_base
        debuginfo "Claim succeeded"
    elseif owner = imm_stack_base then
        debuginfo "Already owned by claimant"
    else
        debuginfo "Already owned by " + str$(owner)
    end if
    $else
    if owner = 0 then imm_arr_set_owner desc, imm_stack_base
    $end if
end sub

'Takes an AST node and frees the array's memory allocation if the caller is the owner.
'Also frees the descriptor if it is a heap object and zeros out the pointer to descriptor
'if needed.
sub imm_do_array_delete(node)
    array = ast_get_child(node, 1)
    desc = imm_get_addr(array)
    'don't free anything if descriptor does not exist
    if desc = 0 then exit sub
    'sanity check, should never occur
    if imm_arr_get_owner(desc) = 0 then imm_error "Deleting unowned array"
    'also don't do anything if the array is owned by someone else
    if imm_arr_get_owner(desc) <> imm_stack_base then exit sub
    imm_heap_free imm_arr_get_data_addr(desc)
    if desc < 0 then
        'descriptor is on the heap, free that too
        imm_heap_free desc
        'clear reference to descriptor
        imm_set_at_addr_n imm_get_addr_loc(array), 0
    end if
end sub
    
'Clear and/or resize an array, doing an initial allocation if needed. If preserve = TRUE,
'any existing data is preserved.
sub imm_do_array_resize(node, preserve)
    dim temp as imm_value_t
    array = ast_get_child(node, 1)
    dimensions = (ast_num_children(node) - 1) / 2
    desc = imm_get_addr(array)
    if desc = 0 then
        'need to allocate descriptor
        desc = imm_heap_alloc(imm_arr_calc_desc_size(dimensions))
        imm_set_at_addr_n imm_get_addr_loc(array), desc
        'explicitly set number of dimensions to 0 so that imm_array_init
        'does not complain
        imm_arr_set_dims desc, dimensions
        imm_arr_set_owner desc, imm_stack_base
        data_addr = 0
    else
        data_addr = imm_arr_get_data_addr(desc)
    end if
    if data_addr = 0 then
        imm_array_init node
    elseif not preserve then
        imm_heap_free data_addr
        imm_array_init node
    else
        'only allow resizing the last dimension because otherwise we would need to
        'rearrange all the data
        array_type = type_of_lvalue(array)
        element_type = array_type->array_type
        cur_dimensions = imm_arr_get_dims(desc)
        if cur_dimensions <> 0 and cur_dimensions <> dimensions then
            imm_error "Cannot change number of array dimensions"
        end if
        old_block_size = 1
        new_block_size = 1
        for i = 1 to dimensions
            'check lower bound
            imm_eval ast_get_child(node, i * 2), temp
            old_lower_bound = imm_arr_get_lbound(desc, i)
            new_lower_bound = temp.n
            if i < dimensions and old_lower_bound <> new_lower_bound then imm_error "Bad array resize"
            'check upper bound
            imm_eval ast_get_child(node, i * 2 + 1), temp
            old_upper_bound = imm_arr_get_ubound(desc, i)
            new_upper_bound = temp.n
            if i < dimensions and old_upper_bound <> new_upper_bound then imm_error "Bad array resize"
            imm_arr_set_lbound desc, i, new_lower_bound
            imm_arr_set_ubound desc, i, new_upper_bound
            old_data_size = old_data_size + (old_upper_bound - old_lower_bound + 1) * old_block_size
            old_block_size = old_upper_bound - old_lower_bound + 1
            new_data_size = new_data_size + (new_upper_bound - new_lower_bound + 1) * new_block_size
            new_block_size = new_upper_bound - new_lower_bound + 1
        next i
        old_data_size = old_data_size * type_fixed_size(element_type)
        new_data_size = new_data_size * type_fixed_size(element_type)
        if new_data_size <= old_data_size then
            'Array is shrinking or staying the same. Since we don't have the ability
            'to shrink allocations, just leave it the same size.
            'TODO implement heap shrinking
        else
            'Array is expanding. Copy data to a new allocation.
            'TODO implement heap expanding
            new_data_addr = imm_heap_alloc(new_data_size)
            for i = 0 to old_data_size - 1
                imm_get_at_addr imm_add_offset(data_addr, i), temp
                imm_set_at_addr imm_add_offset(new_data_addr, i), temp
            next i
            imm_heap_free data_addr
            imm_arr_set_data_addr desc, new_data_addr
        end if
    end if
end sub

'Free array's memory allocation, including the descriptor if it is a heap object.
sub imm_array_delete(desc)
    if desc = 0 then exit sub
    data_addr = imm_arr_get_data_addr(desc)
    if data_addr then imm_heap_free data_addr
    if desc < 0 then imm_heap_free desc
end sub

sub imm_array_init(node)
    dim temp as imm_value_t
    'New array
    array = ast_get_child(node, 1)
    desc = imm_get_addr(array)
    array_type = type_of_lvalue(array)
    element_type = array_type->array_type
    dimensions = (ast_num_children(node) - 1) / 2
    cur_dimensions = imm_arr_get_dims(desc)
    if cur_dimensions <> 0 and cur_dimensions <> dimensions then
        imm_error "Cannot change number of array dimensions"
    end if
    block_size = 1
    imm_arr_set_dims desc, dimensions
    for i = 1 to dimensions
        'evaluate upper and lower bounds for this dimension
        imm_eval ast_get_child(node, i * 2), temp
        lower_bound = temp.n
        imm_eval ast_get_child(node, i * 2 + 1), temp
        upper_bound = temp.n
        'write values to descriptor
        imm_arr_set_lbound desc, i, lower_bound
        imm_arr_set_ubound desc, i, upper_bound
        'accumulate total data block size as number of elements
        data_size = data_size + (upper_bound - lower_bound + 1) * block_size
        block_size = upper_bound - lower_bound + 1
    next i
    'convert to bytes
    data_size = data_size * type_fixed_size(element_type)
    'allocate and store pointer
    data_addr = imm_heap_alloc(data_size)
    imm_arr_set_data_addr desc, data_addr
    temp.n = 0
    temp.s = ""
    imm_memset data_addr, data_size, temp
end sub
    
'If is_ref is true, dest_addr is the address of a pointer to the descriptor.
'It may be a null pointer, indicating the descriptor needs to be created.
'If is_ref is false, dest_addr is the descriptor address.
sub imm_array_copy(src_addr, dest_addr_in, is_ref)
    dest_addr = dest_addr_in
    'Don't try and copy an array onto itself
    if dest_addr = src_addr then exit sub
    src_data_addr = imm_arr_get_data_addr(src_addr)
    if src_data_addr = 0 then
        imm_error "Cannot assign uninitialised array"
    end if
    src_dims = imm_arr_get_dims(src_addr)
    if is_ref then
        dest_ref = dest_addr
        dest_addr = imm_arr_get_data_addr(dest_ref)
    end if
    if is_ref and dest_addr = 0 then
        'need to initialise dest array
        dest_addr = imm_heap_alloc(imm_arr_calc_desc_size(src_dims))
        imm_set_at_addr_n dest_ref, dest_addr
        imm_arr_set_data_addr dest_addr, 0 'No data block yet
        imm_arr_set_dims dest_addr, src_dims
        dest_dims = src_dims
    else
        dest_dims = imm_arr_get_dims(dest_addr)
        if src_dims <> dest_dims then
            imm_error "Array dimensions do not match"
        end if
    end if
    'Copy data block, freeing old one if needed
    dest_data_addr = imm_arr_get_data_addr(dest_addr)
    if dest_data_addr then imm_heap_free dest_data_addr
    dest_data_addr = imm_heap_copy_alloc(src_data_addr)
    imm_arr_set_data_addr dest_addr, dest_data_addr
    'Also copy upper and lower bound information 
    for i = 1 to src_dims
        imm_arr_set_lbound dest_addr, i, imm_arr_get_lbound(src_addr, i)
        imm_arr_set_ubound dest_addr, i, imm_arr_get_ubound(src_addr, i)
    next i
end sub
    
