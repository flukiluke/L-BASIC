'Copyright Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'array.bm - Array handling functions

sub imm_do_array_establish(node)
    array = ast_get_child(node, 1)
    'get address of descriptor
    info_base_addr = imm_get_addr(array)
    'get data block address
    data_addr = imm_get_at_addr_n(info_base_addr)
    if data_addr <> 0 then exit sub
    imm_array_init node
end sub
    
sub imm_do_array_delete(node)
    array = ast_get_child(node, 1)
    'get address of descriptor
    info_base_addr = imm_get_addr(array)
    'don't free anything if descriptor does not exist
    if info_base_addr = 0 then exit sub
    'get data block address
    data_addr = imm_get_at_addr_n(info_base_addr)
    imm_heap_free data_addr
    if info_base_addr < 0 then
        'descriptor is on the heap, free that too
        imm_heap_free info_base_addr
        'clear reference to descriptor
        imm_set_at_addr_n imm_get_addr_loc(array), 0
    end if
end sub

sub imm_array_delete(info_base_addr)
    if info_base_addr = 0 then exit sub
    data_addr = imm_get_at_addr_n(info_base_addr)
    if data_addr then imm_heap_free data_addr
    if info_base_addr < 0 then imm_heap_free info_base_addr
end sub

sub imm_array_init(node)
    dim temp as imm_value_t
    'New array
    'Array descriptor:
    ' - pointer to data
    ' - number of dimensions
    ' - lbound of leftmost dimension
    ' - ubound of leftmost dimension
    ' - etc.
    ' - lbound of rightmost dimension
    ' - ubound of rightmost dimension
    array = ast_get_child(node, 1)
    info_base_addr = imm_get_addr(array)
    data_addr = imm_get_at_addr_n(info_base_addr)
    array_type = type_of_lvalue(array)
    element_type = array_type->array_type
    dimensions = (ast_num_children(node) - 1) / 2
    cur_dimensions = imm_get_at_addr_n(imm_add_offset(info_base_addr, 1))
    if cur_dimensions <> 0 and cur_dimensions <> dimensions then
        imm_error "Cannot change number of array dimensions"
    end if
    block_size = 1
    imm_set_at_addr_n imm_add_offset(info_base_addr, 1), dimensions
    for i = 1 to dimensions
        'evaluate upper and lower bounds for this dimension
        imm_eval ast_get_child(node, i * 2), temp
        lower_bound = temp.n
        imm_eval ast_get_child(node, i * 2 + 1), temp
        upper_bound = temp.n
        'write values to descriptor
        imm_set_at_addr_n imm_add_offset(info_base_addr, i * 2), lower_bound
        imm_set_at_addr_n imm_add_offset(info_base_addr, i * 2 + 1), upper_bound
        'accumulate total data block size as number of elements
        data_size = data_size + (upper_bound - lower_bound + 1) * block_size
        block_size = upper_bound - lower_bound + 1
    next i
    'convert to bytes
    data_size = data_size * type_fixed_size(element_type)
    'allocate and store pointer
    data_addr = imm_heap_alloc(data_size)
    imm_set_at_addr_n info_base_addr, data_addr
    temp.n = 0
    temp.s = ""
    imm_memset data_addr, data_size, temp
end sub
    
sub imm_do_array_resize(node, preserve)
    dim temp as imm_value_t
    array = ast_get_child(node, 1)
    dimensions = (ast_num_children(node) - 1) / 2
    'get address of descriptor
    info_base_addr = imm_get_addr(array)
    if info_base_addr = 0 then
        'need to allocate descriptor
        info_base_addr = imm_heap_alloc(2 + dimensions * 2)
        imm_set_at_addr_n imm_get_addr_loc(array), info_base_addr
        'explicitly set number of dimensions to 0 so that imm_array_init
        'does not complain
        imm_set_at_addr_n imm_add_offset(info_base_addr, 1), dimensions
        data_addr = 0
    else
        'get data block address
        data_addr = imm_get_at_addr_n(info_base_addr)
    end if
    if data_addr = 0 then
        imm_array_init node
    elseif not preserve then
        imm_heap_free data_addr
        imm_array_init node
    else
        'only allow resizing the last dimension because otherwise we would need to
        'rearrange all the data
        array_type = type_of_lvalue(array)
        element_type = array_type->array_type
        cur_dimensions = imm_get_at_addr_n(imm_add_offset(info_base_addr, 1))
        if cur_dimensions <> 0 and cur_dimensions <> dimensions then
            imm_error "Cannot change number of array dimensions"
        end if
        old_block_size = 1
        new_block_size = 1
        for i = 1 to dimensions
            'check lower bound
            imm_eval ast_get_child(node, i * 2), temp
            old_lower_bound = imm_get_at_addr_n(imm_add_offset(info_base_addr, i * 2))
            new_lower_bound = temp.n
            if i < dimensions and old_lower_bound <> new_lower_bound then imm_error "Bad array resize"
            'check upper bound
            imm_eval ast_get_child(node, i * 2 + 1), temp
            old_upper_bound = imm_get_at_addr_n(imm_add_offset(info_base_addr, i * 2 + 1))
            new_upper_bound = temp.n
            if i < dimensions and old_upper_bound <> new_upper_bound then imm_error "Bad array resize"
            imm_set_at_addr_n imm_add_offset(info_base_addr, i * 2), new_lower_bound
            imm_set_at_addr_n imm_add_offset(info_base_addr, i * 2 + 1), new_upper_bound
            old_data_size = old_data_size + (old_upper_bound - old_lower_bound + 1) * old_block_size
            old_block_size = old_upper_bound - old_lower_bound + 1
            new_data_size = new_data_size + (new_upper_bound - new_lower_bound + 1) * new_block_size
            new_block_size = new_upper_bound - new_lower_bound + 1
        next i
        old_data_size = old_data_size * type_fixed_size(element_type)
        new_data_size = new_data_size * type_fixed_size(element_type)
        if new_data_size <= old_data_size then
            'Array is shrinking or staying the same. Since we don't have the ability
            'to shrink allocations, just leave it the same size.
            'TODO implement heap shrinking
        else
            'Array is expanding. Copy data to a new allocation.
            'TODO implement heap expanding
            new_data_addr = imm_heap_alloc(new_data_size)
            for i = 0 to old_data_size - 1
                imm_get_at_addr imm_add_offset(data_addr, i), temp
                imm_set_at_addr imm_add_offset(new_data_addr, i), temp
            next i
            imm_heap_free data_addr
            imm_set_at_addr_n info_base_addr, new_data_addr
        end if
    end if
end sub

'If is_ref is true, dest_addr is the address of a pointer to the descriptor.
'It may be a null pointer, indicating the descriptor needs to be created.
'If is_ref is false, dest_addr is the descriptor address.
sub imm_array_copy(src_addr, dest_addr_in, is_ref)
    dest_addr = dest_addr_in
    'Don't try and copy an array onto itself
    if dest_addr = src_addr then exit sub
    src_data_addr = imm_get_at_addr_n(src_addr)
    if src_data_addr = 0 then
        imm_error "Cannot assign uninitialised array"
    end if
    src_dims = imm_get_at_addr_n(imm_add_offset(src_addr, 1))
    if is_ref then
        dest_ref = dest_addr
        dest_addr = imm_get_at_addr_n(dest_ref)
    end if
    if is_ref and dest_addr = 0 then
        'need to initialise dest array
        dest_addr = imm_heap_alloc(2 + src_dims * 2)
        imm_set_at_addr_n dest_ref, dest_addr
        imm_set_at_addr_n dest_addr, 0 'No data block yet
        imm_set_at_addr_n imm_add_offset(dest_addr, 1), src_dims
        dest_dims = src_dims
    else
        dest_dims = imm_get_at_addr_n(imm_add_offset(dest_addr, 1))
        if src_dims <> dest_dims then
            imm_error "Array dimensions do not match"
        end if
    end if
    'Copy data block, freeing old one if needed
    dest_data_addr = imm_get_at_addr_n(dest_addr)
    if dest_data_addr then imm_heap_free dest_data_addr
    dest_data_addr = imm_heap_copy_alloc(src_data_addr)
    imm_set_at_addr_n dest_addr, dest_data_addr
    'Also copy upper and lower bound information 
    for i = 2 to src_dims * 2 + 1
        imm_set_at_addr_n imm_add_offset(dest_addr, i), imm_get_at_addr_n(imm_add_offset(src_addr, i))
    next i
end sub
