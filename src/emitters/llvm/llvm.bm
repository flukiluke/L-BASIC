'Copyright Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'llvm.bm - Entry point for LLVM based compilation

$include: 'llvm_bindings.bm'

sub ll_build
    dim module as _offset
    module = llvm_module_create_with_name(options.mainarg)
    for i = 1 to symtab_last_entry
        if i->stype = SYM_FUNCTION and i->func_kind = SYM_FUNCTION_USER then
            ll_cg_procedure_entry module, i->proc_node
        end if
    next i
    for i = 1 to symtab_last_entry
        if i->stype = SYM_FUNCTION and i->func_kind = SYM_FUNCTION_USER then
            ll_cg_procedure module, i->proc_node
        end if
    next i
    e = llvm_verify_module(module, LLVMAbortProcessAction, message$)
    e = llvm_write_bitcode_to_file(module, options.outputfile)
    llvm_dispose_module module
end sub

sub ll_cg_procedure_entry(module as _offset, proc_node)
    dim as _offset prototype, param
    numargs = ast_num_children(proc_node) - 1
    dim args(1 to numargs) as _offset
    for i = 1 to numargs
        arg = ast_get_child(proc_node, i + 1)
        var = arg->ref
        if var->vflags AND SYM_VARIABLE_DEREF then
            args(i) = ll_pointer_type(var->type)
        else
            args(i) = ll_type(var->type)
        end if
    next i
    proc = proc_node->ref
    sig = proc->sig
    prototype = llvm_function_type(ll_type(type_sig_return(sig)), args(), numargs, FALSE)
    proc->lp = llvm_add_function(module, proc->identifier, prototype)
    for i = 1 to numargs
        arg = ast_get_child(proc_node, i + 1)
        var = arg->ref
        param = llvm_get_param(proc->lp, i - 1)
        llvm_set_value_name param, var->identifier
        var->lp = param
    next i
end sub

sub ll_cg_procedure(module as _offset, proc_node)
    proc = proc_node->ref
    dim as _offset builder, entryBB, ret
    builder = llvm_create_builder
    entryBB = llvm_append_basic_block(proc->lp, "entry")
    llvm_position_builder_at_end builder, entryBB
    ll_cg_locals builder, proc_node
    ll_cg_block builder, ast_get_child(proc_node, 1)
    ret = llvm_build_ret_void(builder)
    function_ok = llvm_verify_function(proc->lp, LLVMAbortProcessAction)
    llvm_dispose_builder builder
end sub

sub ll_cg_locals(builder as _offset, proc_node)
    'Copy any byval arguments to allocas so they may be treated identically
    dim as _offset ptr, store
    numargs = ast_num_children(proc_node) - 1
    for i = 1 to numargs
        arg = ast_get_child(proc_node, i + 1)
        var = arg->ref
        if (var->vflags AND SYM_VARIABLE_DEREF) = 0 then
            ptr = llvm_build_alloca(builder, ll_type(var->type), var->identifier)
            store = llvm_build_store(builder, var->lp, ptr)
            var->lp = ptr
        end if
    next i
    'Allocate and initialise all other local variables
    proc = proc_node->ref
    var = proc->last_var
    while var
        var->lp = llvm_build_alloca(builder, ll_type(var->type), var->identifier)
        store = llvm_build_store(builder, llvm_const_int(ll_type(var->type), 0, 0), var->lp)
        var = var->prev_var
    wend
end sub

sub ll_cg_block(builder as _offset, block)
    for i = 1 to ast_num_children(block)
        node = ast_get_child(block, i)
        select case node->atype
            case AST_ASSIGN
                ll_cg_assign builder, node
            case AST_IF
                ll_cg_if builder, node
            case AST_WHILE
                'll_cg_while builder, node
            case AST_DO_PRE
                'll_cg_do_pre builder, node
            case AST_DO_POST
                'll_cg_do_post builder, node
            case AST_FOR
                'll_cg_for builder, node
            case AST_SELECT
                'll_cg_select builder, node
            case AST_CALL
                none%& = ll_cg_call(builder, node)
            case AST_GOTO
                'll_cg_goto builder, node
            case AST_EXIT
                'll_cg_exit builder, node
            case AST_SET_RETURN
                'll_cg_set_return builder, node
        end select
    next i
end sub

function ll_pointer_type%&(typ)
    ll_pointer_type%& = llvm_pointer_type(ll_type(typ), 0)
end function

function ll_type%&(typ)
    select case typ
        case TYPE_NONE
            ll_type = llvm_void_type
        case TYPE_BOOL
            ll_type = llvm_int1_type
        case TYPE_INTEGER
            ll_type = llvm_int16_type
        case TYPE_LONG
            ll_type = llvm_int32_type
        case TYPE_INTEGER64
            ll_type = llvm_int64_type
        case else
            fatalerror "bad ll type: " + type_human_readable$(typ)
    end select
end function

function ll_cg_call%&(builder as _offset, node)
    dim as _offset param, dedicated
    numargs = ast_num_children(node)
    target = node->ref
    if target->lp = 0 then
        if (target->stype = SYM_INFIX) or (target->stype = SYM_PREFIX) or ((target->stype = SYM_FUNCTION) and (target->func_kind = SYM_FUNCTION_INTRINSIC)) then
            'This function has a builtin instruction
            dedicated = ll_cg_call_builtin(builder, node)
            if dedicated then
                ll_cg_call%& = dedicated
                exit function
            end if
        end if
        fatalerror "Call to " + target->identifier + " has no target pointer"
    end if
    sig = node->ref2
    dim args(1 to numargs) as _offset
    for i = 1 to numargs
        args(i) = ll_cg_expr(builder, ast_get_child(node, i))
    next i
    ll_cg_call%& = llvm_build_call(builder, target->lp, args(), numargs)
end function

function ll_cg_call_builtin%&(builder as _offset, node)
    dim as _offset v1, v2, ret
    select case node->ref
        case TOK_PLUS
            v1 = ll_cg_expr(builder, ast_get_child(node, 1))
            v2 = ll_cg_expr(builder, ast_get_child(node, 2))
            ret = llvm_build_add(builder, v1, v2, "add")
        case TOK_DASH
            v1 = ll_cg_expr(builder, ast_get_child(node, 1))
            v2 = ll_cg_expr(builder, ast_get_child(node, 2))
            ret = llvm_build_sub(builder, v1, v2, "sub")
        case TOK_EQUALS
            v1 = ll_cg_expr(builder, ast_get_child(node, 1))
            v2 = ll_cg_expr(builder, ast_get_child(node, 2))
            ret = llvm_build_icmp(builder, LLVMIntEQ, v1, v2, "equals")
        case else
            fatalerror "Not a builtin!"
    end select
    ll_cg_call_builtin%& = ret            
end function

function ll_cg_expr%&(builder as _offset, node)
    select case node->atype
        case AST_CALL
            ll_cg_expr%& = ll_cg_call(builder, node)
        case AST_CONSTANT
            ll_cg_expr%& = ll_cg_constant(node)
        case AST_CAST
            ll_cg_expr%& = ll_cg_cast(builder, node)
        case AST_VAR
            ll_cg_expr%& = ll_cg_var(builder, node)
        case else
            fatalerror "Bad expr type"
    end select
end function

function ll_cg_constant%&(node)
    constant = node->ref
    select case ast_constant_types(constant)
        case TYPE_BOOL
            ll_cg_constant%& = llvm_const_int_of_string(llvm_int1_type, ast_constants(constant), 10)
        case TYPE_INTEGER
            ll_cg_constant%& = llvm_const_int_of_string(llvm_int16_type, ast_constants(constant), 10)
        case TYPE_LONG
            ll_cg_constant%& = llvm_const_int_of_string(llvm_int32_type, ast_constants(constant), 10)
        case TYPE_INTEGER64
            ll_cg_constant%& = llvm_const_int_of_string(llvm_int64_type, ast_constants(constant), 10)
        case else
            fatalerror "Bad constant type"
    end select
end function

'Variables in an rvalue context
function ll_cg_var%&(builder as _offset, node)
    var = node->ref
    ll_cg_var%& = llvm_build_load(builder, var->lp, var->identifier)
end function

'Variables in an lvalue context
function ll_cg_var_lval%&(builder as _offset, node)
    var = node->ref
    ll_cg_var_lval%& = var->lp
end function

sub ll_cg_assign(builder as _offset, node)
    dim as _offset lvalue, rvalue, store
    lvalue = ll_cg_var_lval(builder, ast_get_child(node, 1))
    rvalue = ll_cg_expr(builder, ast_get_child(node, 2))
    store = llvm_build_store(builder, rvalue, lvalue)
end sub

function ll_cg_cast%&(builder as _offset, node)
    dim as _offset value
    child = ast_get_child(node, 1)
    value = ll_cg_expr(builder, child)
    src_type = type_of_expr(child)
    dest_type = node->ref
    'Assume integral type for now
    if type_fixed_size(dest_type) > type_fixed_size(src_type) then
        op = LLVMSExt
    else
        op = LLVMTrunc
    end if
    ll_cg_cast%& = llvm_build_cast(builder, op, value, ll_type(dest_type), "cast")
end function

sub ll_cg_if(builder as _offset, node)
    dim as _offset guard, cmp, func, thenBB, elseBB, mergeBB, dummy
    cond_node = ast_get_child(node, 1)
    cond_type = type_of_expr(cond_node)
    guard = ll_cg_expr(builder, cond_node)
    cmp = llvm_build_icmp(builder, LLVMIntNE, guard, llvm_const_int(ll_type(cond_type), 0, 0), "ifcmp")
    func = llvm_get_basic_block_parent(llvm_get_insert_block(builder))
    thenBB = llvm_append_basic_block(func, "then")
    elseBB = llvm_create_basic_block("else")
    mergeBB = llvm_create_basic_block("endif")
    dummy = llvm_build_cond_br(builder, cmp, thenBB, elseBB)
    llvm_position_builder_at_end builder, thenBB
    ll_cg_block builder, ast_get_child(node, 2)
    dummy = llvm_build_br(builder, mergeBB)
    llvm_append_existing_basic_block func, elseBB
    llvm_position_builder_at_end builder, elseBB
    if ast_num_children(node) = 3 then
        ll_cg_block builder, ast_get_child(node, 3)
    end if
    dummy = llvm_build_br(builder, mergeBB)
    llvm_append_existing_basic_block func, mergeBB
    llvm_position_builder_at_end builder, mergeBB
end sub
