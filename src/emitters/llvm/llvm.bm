'Copyright Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'llvm.bm - Entry point for LLVM based compilation

$include: 'llvm_bindings.bm'

sub ll_build
    CurrentModule = llvm_module_create_with_name(options.mainarg)
    for i = 1 to symtab_last_entry
        if i->stype = SYM_FUNCTION and i->func_kind = SYM_FUNCTION_USER then
            ll_cg_procedure_entry i->proc_node
        end if
    next i
    for i = 1 to symtab_last_entry
        if i->stype = SYM_FUNCTION and i->func_kind = SYM_FUNCTION_USER then
            ll_cg_procedure i->proc_node
        end if
    next i
    e = llvm_verify_module(CurrentModule, LLVMAbortProcessAction, message$)
    e = llvm_write_bitcode_to_file(CurrentModule, options.outputfile)
    llvm_dispose_module CurrentModule
end sub

sub ll_cg_procedure_entry(proc_node)
    dim as _offset param
    proc = proc_node->ref
    ll_declare_func proc
    numargs = ast_num_children(proc_node) - 1
    for i = 1 to numargs
        arg = ast_get_child(proc_node, i + 1)
        var = arg->ref
        param = llvm_get_param(proc->lp, i - 1)
        llvm_set_value_name param, var->identifier
        var->lp = param
    next i
end sub

sub ll_cg_procedure(proc_node)
    proc = proc_node->ref
    dim as _offset builder, entryBB, startBB, ret, dummy
    builder = llvm_create_builder
    entryBB = llvm_append_basic_block(proc->lp, "entry")
    llvm_position_builder_at_end builder, entryBB
    ll_cg_locals builder, proc_node
    'Keep the entryBB for allocas so we can more easily add to it later for shadow copies
    startBB = llvm_append_basic_block(proc->lp, "start")
    dummy = llvm_build_br(builder, startBB)
    llvm_position_builder_at_end builder, startBB
    ll_cg_block builder, ast_get_child(proc_node, 1)
    ret = llvm_build_ret_void(builder)
    function_ok = llvm_verify_function(proc->lp, LLVMAbortProcessAction)
    llvm_dispose_builder builder
end sub

sub ll_cg_locals(builder as _offset, proc_node)
    'Copy any byval arguments to allocas so they may be treated identically
    dim as _offset ptr, store, constant_zero
    numargs = ast_num_children(proc_node) - 1
    for i = 1 to numargs
        arg = ast_get_child(proc_node, i + 1)
        var = arg->ref
        if (var->vflags AND SYM_VARIABLE_DEREF) = 0 then
            ptr = llvm_build_alloca(builder, ll_type(var->type), var->identifier)
            store = llvm_build_store(builder, var->lp, ptr)
            var->lp = ptr
        end if
    next i
    'Allocate and initialise all other local variables
    proc = proc_node->ref
    var = proc->last_var
    while var
        var->lp = llvm_build_alloca(builder, ll_type(var->type), var->identifier)
        typ = var->type
        if type_is_int(typ) then
            constant_zero = llvm_const_int(ll_type(var->type), 0, 0)
        else
            constant_zero = llvm_const_real(ll_type(var->type), 0)
        end if
        store = llvm_build_store(builder, constant_zero, var->lp)
        var = var->prev_var
    wend
end sub

sub ll_cg_block(builder as _offset, block)
    for i = 1 to ast_num_children(block)
        node = ast_get_child(block, i)
        select case node->atype
            case AST_ASSIGN
                ll_cg_assign builder, node
            case AST_IF
                ll_cg_if builder, node
            case AST_WHILE
                'll_cg_while builder, node
            case AST_DO_PRE
                'll_cg_do_pre builder, node
            case AST_DO_POST
                'll_cg_do_post builder, node
            case AST_FOR
                'll_cg_for builder, node
            case AST_SELECT
                'll_cg_select builder, node
            case AST_CALL
                none%& = ll_cg_call(builder, node)
            case AST_GOTO
                'll_cg_goto builder, node
            case AST_EXIT
                'll_cg_exit builder, node
            case AST_SET_RETURN
                'll_cg_set_return builder, node
        end select
    next i
end sub

function ll_pointer_type%&(typ)
    ll_pointer_type%& = llvm_pointer_type(ll_type(typ), 0)
end function

function ll_type%&(typ)
    select case typ
        case TYPE_NONE
            ll_type = llvm_void_type
        case TYPE_BOOL
            ll_type = llvm_int1_type
        case TYPE_INTEGER
            ll_type = llvm_int16_type
        case TYPE_LONG
            ll_type = llvm_int32_type
        case TYPE_INTEGER64
            ll_type = llvm_int64_type
        case TYPE_SINGLE
            ll_type = llvm_float_type
        case TYPE_DOUBLE
            ll_type = llvm_double_type
        case TYPE_QUAD
            ll_type = llvm_fp128_type
        case else
            fatalerror "bad ll type: " + type_human_readable$(typ)
    end select
end function

function ll_cg_call%&(builder as _offset, node)
    dim as _offset param, dedicated
    numargs = ast_num_children(node)
    target = node->ref
    if target->lp = 0 then
        'Maybe a builtin instruction
        dedicated = ll_cg_call_builtin(builder, node)
        if dedicated then
            ll_cg_call%& = dedicated
            exit function
        end if
        'Must be first use of an external function
        ll_declare_func target
        'Still nothing, throw an error (should never happen)
        if target->lp = 0 then fatalerror "Call to " + target->identifier + " has no target pointer"
    end if
    sig = node->ref2
    dim args(1 to numargs) as _offset
    for i = 1 to numargs
        if type_sig_argflags(sig, i) AND TYPE_BYVAL then
            args(i) = ll_cg_expr(builder, ast_get_child(node, i))
        else
            args(i) = ll_cg_shadow_expr(builder, ast_get_child(node, i))
        end if
    next i
    ll_cg_call%& = llvm_build_call(builder, target->lp, args(), numargs)
end function

function ll_cg_shadow_expr%&(builder as _offset, expr)
    dim as _offset currentBB, entryBB, alloca, value, dummy
    typ = type_of_expr(expr)
    currentBB = llvm_get_insert_block(builder)
    entryBB = llvm_get_entry_basic_block(llvm_get_basic_block_parent(currentBB))
    llvm_position_builder_before builder, llvm_get_basic_block_terminator(entryBB)
    alloca = llvm_build_alloca(builder, ll_type(typ), "shadow")
    llvm_position_builder_at_end builder, currentBB
    value = ll_cg_expr(builder, expr)
    dummy = llvm_build_store(builder, value, alloca)
    ll_cg_shadow_expr%& = alloca
end function

sub ll_declare_func(func)
    dim as _offset prototype
    sig = func->sig
    numargs = type_sig_numargs(sig)
    dim args(1 to numargs) as _offset
    for i = 1 to numargs
        if type_sig_argflags(sig, i) AND TYPE_BYVAL then
            args(i) = ll_type(type_sig_argtype(sig, i))
        else
            args(i) = ll_pointer_type(type_sig_argtype(sig, i))
        end if
    next i
    prototype = llvm_function_type(ll_type(type_sig_return(sig)), args(), numargs, FALSE)
    func->lp = llvm_add_function(CurrentModule, func->identifier, prototype)
end sub

function ll_cg_call_builtin%&(builder as _offset, node)
    dim as _offset v1, v2, ret
    select case node->ref
        case TOK_PLUS
            c1 = ast_get_child(node, 1)
            v1 = ll_cg_expr(builder, c1)
            v2 = ll_cg_expr(builder, ast_get_child(node, 2))
            if type_is_int(type_of_expr(c1)) then
                ret = llvm_build_add(builder, v1, v2, "add")
            elseif type_is_fp(type_of_expr(c1)) then
                ret = llvm_build_fadd(builder, v1, v2, "fadd")
            end if
        case TOK_DASH
            c1 = ast_get_child(node, 1)
            v1 = ll_cg_expr(builder, c1)
            v2 = ll_cg_expr(builder, ast_get_child(node, 2))
            if type_is_int(type_of_expr(c1)) then
                ret = llvm_build_sub(builder, v1, v2, "sub")
            elseif type_is_fp(type_of_expr(c1)) then
                ret = llvm_build_fsub(builder, v1, v2, "fsub")
            end if
        case TOK_EQUALS
            c1 = ast_get_child(node, 1)
            v1 = ll_cg_expr(builder, c1)
            v2 = ll_cg_expr(builder, ast_get_child(node, 2))
            if type_is_int(type_of_expr(c1)) then
                ret = llvm_build_icmp(builder, LLVMIntEq, v1, v2, "inteq")
            elseif type_is_fp(type_of_expr(c1)) then
                ret = llvm_build_fcmp(builder, LLVMRealOEQ, v1, v2, "fpeq")
            end if
    end select
    ll_cg_call_builtin%& = ret            
end function

function ll_cg_expr%&(builder as _offset, node)
    select case node->atype
        case AST_CALL
            ll_cg_expr%& = ll_cg_call(builder, node)
        case AST_CONSTANT
            ll_cg_expr%& = ll_cg_constant(node)
        case AST_CAST
            ll_cg_expr%& = ll_cg_cast(builder, node)
        case AST_VAR
            ll_cg_expr%& = ll_cg_var(builder, node)
        case else
            fatalerror "Bad expr type"
    end select
end function

function ll_cg_constant%&(node)
    constant = node->ref
    select case ast_constant_types(constant)
        case TYPE_BOOL
            ll_cg_constant%& = llvm_const_int_of_string(llvm_int1_type, ast_constants(constant), 10)
        case TYPE_INTEGER
            ll_cg_constant%& = llvm_const_int_of_string(llvm_int16_type, ast_constants(constant), 10)
        case TYPE_LONG
            ll_cg_constant%& = llvm_const_int_of_string(llvm_int32_type, ast_constants(constant), 10)
        case TYPE_INTEGER64
            ll_cg_constant%& = llvm_const_int_of_string(llvm_int64_type, ast_constants(constant), 10)
        case else
            fatalerror "Bad constant type"
    end select
end function

'Variables in an rvalue context
function ll_cg_var%&(builder as _offset, node)
    var = node->ref
    ll_cg_var%& = llvm_build_load(builder, var->lp, var->identifier)
end function

'Variables in an lvalue context
function ll_cg_var_lval%&(builder as _offset, node)
    var = node->ref
    ll_cg_var_lval%& = var->lp
end function

sub ll_cg_assign(builder as _offset, node)
    dim as _offset lvalue, rvalue, store
    lvalue = ll_cg_var_lval(builder, ast_get_child(node, 1))
    rvalue = ll_cg_expr(builder, ast_get_child(node, 2))
    store = llvm_build_store(builder, rvalue, lvalue)
end sub

function ll_cg_cast%&(builder as _offset, node)
    dim as _offset value
    child = ast_get_child(node, 1)
    value = ll_cg_expr(builder, child)
    src_type = type_of_expr(child)
    dest_type = node->ref
    if type_is_int(src_type) and type_is_int(dest_type) then
        if type_fixed_size(dest_type) > type_fixed_size(src_type) then
            op = LLVMSExt
        else
            op = LLVMTrunc
        end if
    elseif type_is_int(src_type) and type_is_fp(dest_type) then
        op = LLVMSIToFP
    elseif type_is_fp(src_type) and type_is_int(dest_type) then
        op = LLVMFPToSI
    elseif type_is_fp(src_type) and type_is_fp(dest_type) then
        if type_fixed_size(dest_type) > type_fixed_size(src_type) then
            op = LLVMFPExt
        else
            op = LLVMFPTrunc
        end if
    else
        fatalerror "Bad cast"
    end if
    ll_cg_cast%& = llvm_build_cast(builder, op, value, ll_type(dest_type), "cast")
end function

sub ll_cg_if(builder as _offset, node)
    dim as _offset guard, cmp, func, thenBB, elseBB, mergeBB, dummy
    cond_node = ast_get_child(node, 1)
    cond_type = type_of_expr(cond_node)
    guard = ll_cg_expr(builder, cond_node)
    if type_is_int(cond_type) then
        cmp = llvm_build_icmp(builder, LLVMIntNE, guard, llvm_const_int(ll_type(cond_type), 0, 0), "ifcmp")
    elseif type_is_fp(cond_type) then
        cmp = llvm_build_fcmp(builder, LLVMRealONE, guard, llvm_const_real(ll_type(cond_type), 0), "ifcmp")
    end if
    func = llvm_get_basic_block_parent(llvm_get_insert_block(builder))
    thenBB = llvm_append_basic_block(func, "then")
    elseBB = llvm_create_basic_block("else")
    mergeBB = llvm_create_basic_block("endif")
    dummy = llvm_build_cond_br(builder, cmp, thenBB, elseBB)
    llvm_position_builder_at_end builder, thenBB
    ll_cg_block builder, ast_get_child(node, 2)
    dummy = llvm_build_br(builder, mergeBB)
    llvm_append_existing_basic_block func, elseBB
    llvm_position_builder_at_end builder, elseBB
    if ast_num_children(node) = 3 then
        ll_cg_block builder, ast_get_child(node, 3)
    end if
    dummy = llvm_build_br(builder, mergeBB)
    llvm_append_existing_basic_block func, mergeBB
    llvm_position_builder_at_end builder, mergeBB
end sub
