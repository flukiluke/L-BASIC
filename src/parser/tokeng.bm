'Copyright 2020 Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'tokeng.bm - Tokeniser Engine

deflng a-z

sub tok_init
    'Read in the state machine
    for s = 1 to ubound(t_states~%, 2)
        read t_statenames$(s)
        for b = 1 to 127
            read cmd
            t_states~%(b, s) = cmd
        next b
    next s
    tokeng_state.index = 1
    tokeng_state.curstate = 1
    tokeng_state.has_data = FALSE
    tokeng_state.linestart = TRUE
    'Fill the 'next' buffer and propagate to tok_token
    tok_read_next_token
    tok_advance
end sub

sub tok_advance
    tok_token = tok_next_token
    tok_content$ = tok_next_content$
    if not options.interactive_mode then
        tok_read_next_token
    else
        if tok_token = TOK_NEWLINE then
            'All lines end with TOK_EOI
            tok_next_token = TOK_EOI
        elseif tok_token = TOK_EOI then
            'No line starts with TOK_NEWLINE
            do
                tok_read_next_token
            loop while tok_next_token = TOK_NEWLINE
        else
            tok_read_next_token
        end if
    end if
    debuginfo tok_human_readable$(tok_token) + " <- " + tok_human_readable$(tok_next_token)

end sub

sub tok_read_next_token
    if not tokeng_state.has_data then
        if general_eof then
            tok_next_token = TOK_EOF
            exit function
        end if
        tokeng_state.index = 1
        tokeng_state.raw_line_in = general_next_line$
        tokeng_state.has_data = TRUE
    end if

    tok_next_content$ = tok_next_ts$(tokeng_state.raw_line_in + chr$(10), ts_type)

    select case ts_type
        case 0 'Out of data (an error)
            ps_error "Unexpected end of line"

        case TS_ID
            'Special cases!
            if tok_next_content$ = "?" then
                tok_next_content$ = "PRINT"
            elseif ucase$(tok_next_content$) = "REM" then
                goto rem_hack
            end if
                
            id = symtab_get_id(ucase$(tok_next_content$))
            if id = 0 then
                tok_next_token = TOK_UNKNOWN
            else
                tok_next_token = id
            end if
            tokeng_state.linestart = FALSE

        case TS_NEWLINE
            rem_hack:
            tokeng_state.has_data = FALSE
            tokeng_state.linestart = TRUE
            tok_next_token = TOK_NEWLINE

        case else
            if tok_direct(ts_type) then
                tok_next_token = tok_direct(ts_type)
            else
                ps_error "Unhandled TS" + str$(ts_type)
            end if
            tokeng_state.linestart = FALSE
    end select
end function

function tok_next_ts$(text$, ts_type)
    if tokeng_state.index > len(text$) then
        'Out of data
        ts_type = 0
        exit function
    end if
    for i = tokeng_state.index to len(text$)
        c = asc(text$, i)
        'No utf-8 support for now
        if c > 127 then ps_error "Character outside character set (" + ltrim$(str$(c)) + ")"
        command = t_states~%(c, tokeng_state.curstate)
        'Rules of the form "A: B ~ Error" encode to 0
        if command = 0 then ps_error chr$(34) + chr$(c) + chr$(34) + " from " + t_statenames$(tokeng_state.curstate) + " illegal"
        'High byte is next state, low byte is token, high bit of low byte is pushback flag
        ts_type_internal = command and 127
        pushback = command and 128
        'print t_statenames$(tokeng_state.curstate); ":"; c; "~ ";
        tokeng_state.curstate = command \ 2^8
        'print t_statenames$(tokeng_state.curstate)
        if ts_type_internal > 0 then
            ts_type = ts_type_internal
            if pushback then
                'This doesn't include the current character, and uses it next time...
                if ts_type <> 1 then tok_next_ts$ = mid$(text$, tokeng_state.index, i - tokeng_state.index)
                tokeng_state.index = i
            else
                '...but this does include it, and starts from the next character next time.
                if ts_type <> 1 then tok_next_ts$ = mid$(text$, tokeng_state.index, i - tokeng_state.index + 1)
                tokeng_state.index = i + 1
            end if
            if ts_type <> TS_SKIP then exit function
        end if
    next i
    ts_type = 0
end function 

function tok_human_readable$(token)
    if token > 0 then
        tok_human_readable$ = symtab(token).identifier
    else
        tok_human_readable$ = "LITERAL_" + mid$(str$(token), 2)
    end if
end function

'$include: '../../rules/ts_data.bm'
