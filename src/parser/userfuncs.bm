'Copyright 2020 Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'userfuncs.bm - Parse rules for SUB and FUNCTION definitions

'Expects: TOK_DECLARE
'Results: NEWLINE
function ps_declare
    $if DEBUG_PARSE_TRACE then
    debuginfo "Start declare"
    $end if
    ps_consume TOK_DECLARE
    if ps_consumed(TOK_SUB) then is_sub = TRUE else ps_consume(TOK_FUNCTION)
    if tok_token <> TOK_UNKNOWN then
        ps_error "Name already in use"
    end if
    dim sym as symtab_entry_t
    sym.identifier = ucase$(tok_content$)
    sym.typ = SYM_FUNCTION
    tok_advance
    if is_sub then return_type = TYPE_NONE else return_type = ps_opt_sigil
    if return_type = 0 then return_type = ps_default_type
    sym.v1 = type_add_sig(0, type_sigt_create$(return_type)) 
    if ps_consumed(TOK_OPAREN) then
        sig$ = ps_formal_args$(0)
        type_sig_merge sym.v1, sig$
        ps_consume TOK_CPAREN
    end if
    sym.v2 = SYM_FUNCTION_USER
    sym.v3 = 0 'We have no implementation for this function yet
    symtab_add_entry sym
    proc_id = symtab_last_entry
    ps_declare = 0
    $if DEBUG_PARSE_TRACE then
    debuginfo "Completed declare"
    $end if
end function

'Expects: TOK_FUNCTION or TOK_SUB
'Results: NEWLINE
'Return -2, which is handled particularly by ps_block, ps_stmt and interactive_mode
function ps_userfunc
    $if DEBUG_PARSE_TRACE then
    debuginfo "Start userfunc"
    $end if
    if ps_final_nested then
        ps_error "SUB and FUNCTION must appear at top level"
    end if
    if ps_consumed(TOK_SUB) then is_sub = TRUE else ps_consume(TOK_FUNCTION)
    
    if tok_token <> TOK_UNKNOWN then
        if symtab(tok_token).typ <> SYM_FUNCTION then ps_error "Existing name is not a function"
        'if not preload mode and (intrinsic function or implemented user function)
        if not ps_is_preload and (symtab(tok_token).v2 <> SYM_FUNCTION_USER or symtab(tok_token).v3 <> 0) then ps_error "Function already exists"
        override_sym = tok_token
    end if

    dim sym as symtab_entry_t
    sym.identifier = ucase$(tok_content$)
    sym.typ = SYM_FUNCTION
    tok_advance

    root = ast_add_node(AST_PROCEDURE)
    ps_add_nested_structure root
    ps_scope_identifier$ = sym.identifier
    'Save this value so we can restore it later
    saved_var_index = ps_next_var_index
    ps_next_var_index = 1

    if is_sub then return_type = TYPE_NONE else return_type = ps_opt_sigil
    if return_type = 0 then return_type = ps_default_type

    new_sig = type_add_sig(0, type_sigt_create$(return_type)) 
    if ps_consumed(TOK_OPAREN) then
        sig$ = ps_formal_args$(root)
        type_sig_merge new_sig, sig$
        ps_consume TOK_CPAREN
    end if

    if override_sym then
        'Overriding existing function, or implementing a declaration
        'TODO: Be more smart about the type signature for intrinsics
        if symtab(override_sym).v2 = SYM_FUNCTION_USER and _
            type_signatures(symtab(override_sym).v1).sig <> type_signatures(new_sig).sig then
            print type_human_sig$(type_signatures(symtab(override_sym).v1).sig)
            print type_human_sig$(type_signatures(new_sig).sig)
            ps_error "Type signature does not match existing"
        end if
        symtab(override_sym).v2 = SYM_FUNCTION_USER
        symtab(override_sym).v3 = root
        proc_id = override_sym
    else
        sym.v1 = new_sig
        sym.v2 = SYM_FUNCTION_USER
        sym.v3 = root
        symtab_add_entry sym
        proc_id = symtab_last_entry
    end if
    ast_nodes(root).ref = proc_id

    'TODO: STATIC and other modifiers

    ps_consume TOK_NEWLINE
    block = ps_block
    for i = 1 to len(ps_queued_nodes$) - 3 step 4
        other = cvl(mid$(ps_queued_nodes$, i, 4))
        ast_attach block, other
    next i
    ps_queued_nodes$ = ""

    ast_pre_attach root, block
    ps_consume TOK_END
    if is_sub then ps_consume TOK_SUB else ps_consume TOK_FUNCTION
    symtab(proc_id).v4 = ps_next_var_index - 1
    ps_next_var_index = saved_var_index

    ps_scope_identifier$ = ""
    ps_remove_nested_structure

    ps_userfunc = -2
    $if DEBUG_PARSE_TRACE then
    debuginfo "Completed userfunc"
    $end if
end function

'Expects: token after OPAREN
'Result: CPAREN
'Return list of formal args. If root is <> 0, attach AST_VAR nodes.
function ps_formal_args$(root)
    $if DEBUG_PARSE_TRACE then
    debuginfo "Start formal args"
    $end if
    result$ = type_sigt_create$(0)
    do
        flags = 0
        do
            select case tok_token
            case TOK_BYREF
                if flags and TYPE_BYREF then ps_error "Duplicate modifier"
                flags = flags OR TYPE_BYREF
                tok_advance
            case TOK_BYVAL
                if flags and TYPE_BYVAL then ps_error "Duplicate modifier"
                flags = flags OR TYPE_BYVAL
                tok_advance
            case TOK_OPTION
                if flags and TYPE_OPTIONAL then ps_error "Duplicate modifier"
                flags = flags OR TYPE_OPTIONAL
                tok_advance
            case else
                exit do
            end select
        loop
        if tok_token <> TOK_UNKNOWN then ps_error "Expected new variable name"
        'Our calling convention can't handle optional byval arguments
        if ((flags AND TYPE_BYVAL) <> 0) and ((flags AND TYPE_OPTIONAL) <> 0) then
            ps_error "Optional arguments cannot be BYVAL"
        end if
        if root then
            var = ps_simple_variable
            if (flags AND TYPE_BYVAL) = 0 then
                'Default to making the argument pass-by-reference
                symtab(ast_nodes(var).ref).v4 = TRUE
            end if
            ast_attach root, var
            typ = type_of_var(var)
        else
            'Stripped down variable parser used just for declarations
            tok_advance 'Skip name
            typ = ps_opt_sigil
        end if
        result$ = type_sigt_add_arg(result$, typ, flags)
    loop while ps_consumed(TOK_COMMA)
    ps_formal_args$ = result$
    $if DEBUG_PARSE_TRACE then
    debuginfo "Completed formal args"
    $end if
end function

'Expects: function name token
'Result: NEWLINE if valid return assignment, unchanged otherwise
'Returns node if this is a function return value assignment, 0 otherwise
function ps_func_return
    $if DEBUG_PARSE_TRACE then
    debuginfo "Start func return"
    $end if
    'Are we in a procedure with a matching name?
    u$ = ucase$(tok_content$)
    if u$ <> ps_scope_identifier$ then
        $if DEBUG_PARSE_TRACE then
        debuginfo "Completed func return"
        $end if
        exit function
    end if
    proc_id = symtab_get_id(u$)
    'Is this actually a function, not a sub?
    return_type = type_sig_return(symtab(proc_id).v1)
    if return_type = 0 then
        $if DEBUG_PARSE_TRACE then
        debuginfo "Completed func return"
        $end if
        exit function
    end if
    tok_advance
    'Ensure any type sigils match
    sigil = ps_opt_sigil
    if sigil <> 0 and return_type <> sigil then ps_error "Function return type not consistent"
    'Ok, definitely setting the return value
    ps_consume TOK_EQUALS
    root = ast_add_node(AST_SET_RETURN)
    expr = ps_expr
    expr_type = type_of_expr(expr)
    if not type_can_cast(expr_type, return_type) then ps_error "Function return type does not match that of expression"
    expr = ast_add_cast(expr, return_type)
    ast_attach root, expr
    ps_func_return = root
    $if DEBUG_PARSE_TRACE then
    debuginfo "Completed func return"
    $end if
end function
