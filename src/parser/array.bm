'Copyright 2020 Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'array.bm - Parse rules for array declaration and usage

'Expects: (
'Results: token after ) or sigil, if present
'This sub produces AST_ARRAY_DELETE and AST_ARRAY_RESIZE operations
'and adds them to the supplied block. It also generates the symtab entries
'for the array itself and its type.
sub ps_dim_array(token, var_name$, sigil, block, is_shared, preserve, is_static)
    $if DEBUG_PARSE_TRACE then
    debuginfo "Start dim array"
    $end if
    'array declaration. dims$ will be a series of pairs of AST_EXPR,
    'which are the lower and upper bounds for each dimension.
    dim sym as symtab_entry_t
    do
        dims$ = dims$ + mkl$(ps_expr)
        if ps_consumed(TOK_TO) then
            dims$ = dims$ + mkl$(ps_expr)
        else
            'Whoops, there was in implicit lower bound. Add it in.
            implicit_zero = ast_add_node(AST_CONSTANT)
            ast_nodes(implicit_zero).ref = AST_FALSE
            dims$ = left$(dims$, len(dims$) - 4) + mkl$(implicit_zero) + right$(dims$, 4)
        end if
    loop while ps_consumed(TOK_COMMA)
    ps_assert TOK_CPAREN
    tok_advance

    sigil2 = ps_opt_sigil
    if sigil2 > 0 and sigil > 0 then ps_error "Cannot give type twice"
    if sigil2 then sigil = sigil2
    if sigil = 0 then sigil = ps_default_type

    if token <> TOK_UNKNOWN then existing_array = token

    'First we construct the array's type
    array_type_name$ = symtab(sigil).identifier + "(" + ltrim$(str$(len(dims$) / 4 / 2)) + ")"
    array_type_sym = symtab_get_id(array_type_name$)
    if existing_array and symtab(existing_array).v1 <> array_type_sym then
        ps_error "Cannot change array type"
    end if
    if array_type_sym = 0 then
        sym.identifier = array_type_name$
        sym.typ = SYM_TYPE
        'Array descriptor:
        ' - pointer to data
        ' - number of dimensions
        ' - lbound of leftmost dimension
        ' - ubound of leftmost dimension
        ' - etc.
        ' - lbound of rightmost dimension
        ' - ubound of rightmost dimension
        sym.v1 = 2 + len(dims$) / 4
        sym.v2 = SYM_TYPE_ARRAY
        sym.v3 = sigil
        sym.v4 = len(dims$) / 4 / 2
        symtab_add_entry sym
        array_type_sym = symtab_last_entry
    end if

    'Now we have a SYM_ for the type, we can create the actual array variable
    if existing_array = 0 then
        if is_shared then
            sym.identifier = ucase$(var_name$)
        else
            sym.identifier = ps_scope$ + ucase$(var_name$)
        end if
        sym.typ = SYM_VARIABLE
        sym.v1 = array_type_sym
        sym.v2 = ps_next_var_index
        ps_next_var_index = ps_next_var_index + type_fixed_size(sym.v1)
        if is_static or is_shared then sym.v3 = SYM_VARIABLE_MAINFRAME else sym.v3 = 0
        symtab_add_entry sym
        var = symtab_last_entry
    else
        var = existing_array
    end if

    var_node = ast_add_node(AST_VAR)
    ast_nodes(var_node).ref = var
    if preserve then
        node = ast_add_node(AST_ARRAY_RESIZE)
    else
        node = ast_add_node(AST_ARRAY_CREATE)
    end if
    ast_attach node, var_node
    ast_attach block, node
    ast_children(node) = mkl$(var_node) + dims$

    'Generate an array destructor if:
    ' - we are in a procedure (no need to destruct at program exit), and
    ' - the array is not from an outer scope (don't destruct SHARED arrays), and
    ' - the variable is not a reference (would imply it is owned by a caller).
    proc = ps_last_nested(AST_PROCEDURE)
    if proc > 0 and _
            symtab(ast_nodes(proc).ref).identifier = ps_get_scope$(var) and _
            (symtab(var).v3 AND SYM_VARIABLE_DEREF) = 0 then
        'Have a check to see if there's already a destructor.
        'This could occur if there are multiple DIMs in the same function.
        for i = 1 to len(ps_queued_nodes$) - 3 step 4
            other = cvl(mid$(ps_queued_nodes$, i, 4))
            if ast_nodes(other).typ = AST_ARRAY_DELETE and _
                ast_nodes(ast_get_child(other, 1)).ref = var then goto array_dstr_dup
        next i
        node = ast_add_node(AST_ARRAY_DELETE)
        ast_attach node, var_node
        ps_queue_cleanup node
    end if
    array_dstr_dup:
    $if DEBUG_PARSE_TRACE then
    debuginfo "Completed dim array"
    $end if
end sub

'Expects: First index of array access
'Results: token after )
'Takes array variable as argument
function ps_array_element_access(lvalue)
    $if DEBUG_PARSE_TRACE then
    debuginfo "Start array element access"
    $end if
    array_type = type_of_lvalue(lvalue)
    if symtab(array_type).v2 <> SYM_TYPE_ARRAY then ps_error "Value is not an array"
    dimensions = symtab(array_type).v4
    node = ast_add_node(AST_ARRAY_ACCESS)
    ast_attach node, lvalue
    do
        ast_attach node, ps_expr
    loop while ps_consumed(TOK_COMMA)
    ps_assert TOK_CPAREN
    tok_advance
    if ast_num_children(node) - 1 <> dimensions then ps_error "Incorrect number of dimensions"
    ps_array_element_access = node
    $if DEBUG_PARSE_TRACE then
    debuginfo "Completed array element access"
    $end if
end function
